<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Three.js VR - Transparent Gradients + Grain</title>
</head>
<body style="margin:0; padding:0; overflow:hidden;">
<script type="module">
    /*************************************************************************
     * ✅ FIXED: Use Three.js CDN for Imports
     *************************************************************************/
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js';
    import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/webxr/VRButton.js';

    // ✅ Fix Postprocessing Imports
    import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/postprocessing/RenderPass.js';
    import { FilmPass } from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/postprocessing/FilmPass.js';

    /*************************************************************************
     * 2) Configuration
     *************************************************************************/
    const numLayers = 20; // Fewer layers for VR performance
    const pastelPalette = ["#b2dfdb", "#ffe0b2", "#c5cae9", "#ffccbc", "#e1bee7"];

    // Scene, camera, renderer, postprocessing
    let scene, camera, renderer;
    let clock;
    let analyser, sound;
    let composer;
    let layersData = [];

    init();

    /*************************************************************************
     * ✅ 3) Transparent Gradient Shader
     *************************************************************************/
    function createGradientMaterial(colorTop, colorBottom) {
        return new THREE.ShaderMaterial({
            transparent: true,
            depthWrite: false, 
            depthTest: false,
            blending: THREE.NormalBlending,
            uniforms: {
                uColor1: { value: new THREE.Color(colorTop) },
                uColor2: { value: new THREE.Color(colorBottom) }
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                void main() {
                    vec3 color = mix(uColor1, uColor2, vUv.y);
                    gl_FragColor = vec4(color, 0.5); // Semi-transparent
                }
            `,
            side: THREE.DoubleSide
        });
    }

    function init() {
        /*************************************************************************
         * ✅ 4) Scene & Camera
         *************************************************************************/
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
        camera.position.set(0, 1.6, 5);
        scene.add(camera);

        /*************************************************************************
         * ✅ 5) Renderer
         *************************************************************************/
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        clock = new THREE.Clock();

        /*************************************************************************
         * ✅ 6) Audio
         *************************************************************************/
        const listener = new THREE.AudioListener();
        camera.add(listener);
        sound = new THREE.Audio(listener);
        const audioLoader = new THREE.AudioLoader();
        audioLoader.load("StanfordOutpatient3piano.mp3", (buffer) => {
            sound.setBuffer(buffer);
            sound.setLoop(true);
        });
        analyser = new THREE.AudioAnalyser(sound, 512);

        /*************************************************************************
         * ✅ 7) Build Layers
         *************************************************************************/
        for (let i = 0; i < numLayers; i++) {
            const group = new THREE.Group();
            scene.add(group);

            let dataObj = {
                group,
                basePos: new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, -i * 0.3),
                squares: []
            };

            buildSquaresShape(dataObj, i);
            layersData.push(dataObj);
        }

        /*************************************************************************
         * ✅ 8) VR-Compatible Postprocessing (Film Grain)
         *************************************************************************/
        composer = new EffectComposer(renderer);
        composer.setSize(window.innerWidth, window.innerHeight);
        composer.setPixelRatio(window.devicePixelRatio);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);
        const filmPass = new FilmPass(0.2, 0.0, 0, false);
        composer.addPass(filmPass);

        window.addEventListener("resize", onWindowResize, false);
        renderer.setAnimationLoop(() => {
            updateScene();
            composer.render();
        });

        window.addEventListener("pointerdown", () => {
            if (!sound.isPlaying) {
                sound.play();
            }
        });
    }

    /*************************************************************************
     * ✅ 9) Build Squares Shape (Transparent Gradients)
     *************************************************************************/
    function buildSquaresShape(dataObj, layerIndex) {
        const { group } = dataObj;
        let size = 2.0;
        let geo = new THREE.PlaneGeometry(size, size);
        let colorA = pastelPalette[Math.floor(Math.random() * pastelPalette.length)];
        let colorB = pastelPalette[Math.floor(Math.random() * pastelPalette.length)];
        let mat = createGradientMaterial(colorA, colorB);
        let mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.z = Math.random() * Math.PI;
        group.add(mesh);
    }

    function updateScene() {
        layersData.forEach((layer) => {
            layer.group.rotation.z += 0.001;
        });
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }
</script>
</body>
</html>
