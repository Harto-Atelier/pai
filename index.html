<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Three.js XR Audio Reactive Example</title>
  </head>
  <body style="margin:0; padding:0; overflow:hidden;">

    <script type="module">
      /***************************************************************
       * Import Three.js (as ES module) and ARButton from the examples
       ***************************************************************/
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/webxr/ARButton.js';

      /***************************************************************
       * Configuration & Global Variables
       ***************************************************************/
      const numLayers = 200;
      const numPoints = 4;
      const angleStep = 360 / numPoints;

      const mutedPalette = ["#373636", "#D20049", "#C0B8A0", "#3F51B5", "#E70303"];

      // Similar to p5 random data
      let rotationOffsets = [];
      let chessParams = [];

      // Keep groups for each layer
      let layers = [];

      // Three.js main objects
      let scene, camera, renderer;
      let listener, sound, analyser;
      let clock;

      /***************************************************************
       * Initialization
       ***************************************************************/
      init();

      function init() {
        // Scene & Camera
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          1000
        );
        camera.position.set(0, 0, 500);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // AR Button
        document.body.appendChild(ARButton.createButton(renderer));

        // Clock for time-based animation
        clock = new THREE.Clock();

        // Audio setup
        listener = new THREE.AudioListener();
        camera.add(listener);

        sound = new THREE.Audio(listener);
        const audioLoader = new THREE.AudioLoader();

        // Load your MP3 (adjust path as needed)
        audioLoader.load("StanfordOutpatient3_piano.mp3", function (buffer) {
          sound.setBuffer(buffer);
          sound.setLoop(true);
          // Typically you must start audio on a user gesture or after an AR session begins
          // You can also call sound.play() in a user-initiated event (e.g. pointerdown).
        });

        // Create an analyser with a chosen fftSize (1024, 2048, etc. for more detail)
        analyser = new THREE.AudioAnalyser(sound, 1024);

        // Precompute random data for each layer
        for (let i = 0; i < numLayers; i++) {
          rotationOffsets.push(randRange(-0.5, 0.5));

          let cols = Math.floor(randRange(2, 3.999));
          let rows = Math.floor(randRange(2, 5.999));

          let c1 = Math.floor(randRange(0, mutedPalette.length));
          let c2 = Math.floor(randRange(0, mutedPalette.length));
          while (c2 === c1) {
            c2 = Math.floor(randRange(0, mutedPalette.length));
          }

          chessParams.push({
            cols,
            rows,
            color1Index: c1,
            color2Index: c2,
          });

          // Each layer is a group
          let group = new THREE.Group();
          layers.push(group);
          scene.add(group);
        }

        // Adjust on resize
        window.addEventListener("resize", onWindowResize, false);

        // Use setAnimationLoop for XR rendering
        renderer.setAnimationLoop(render);
      }

      /***************************************************************
       * Resize Handler
       ***************************************************************/
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      /***************************************************************
       * Render Loop
       ***************************************************************/
      function render() {
        const elapsed = clock.getElapsedTime();
        const spectrum = analyser.getFrequencyData();

        // Bass/mid/treble energies:
        const bassEnergy = getFrequencyRangeAverage(analyser, 20, 140);
        const midEnergy = getFrequencyRangeAverage(analyser, 140, 1000);
        const trebleEnergy = getFrequencyRangeAverage(analyser, 1000, 20000);

        // amplitude = mid range
        let amplitude = midEnergy;

        let intensityFactor = mapValue(amplitude, 0, 255, 0.03, 0.25);
        let sizeVariation = mapValue(trebleEnergy, 0, 255, 0.5, 5);

        // Rebuild or update each layer's geometry
        layers.forEach((group, i) => {
          // Clear group from previous frame
          while (group.children.length > 0) {
            group.remove(group.children[0]);
          }

          let freqIndex = Math.floor(mapValue(i, 0, numLayers, 0, spectrum.length - 1));
          let baseRadius = mapValue(spectrum[freqIndex], 0, 255, 50, 180);
          let radius = baseRadius * intensityFactor;

          // Rotation offset
          group.rotation.z = elapsed * rotationOffsets[i];

          // Displacements
          let displaceX = Math.sin(elapsed * 0.01 + i * 0.1) * 15;
          let displaceY = Math.cos(elapsed * 0.01 + i * 0.1) * 155;
          group.position.set(displaceX, displaceY, 0);

          if (i % 3 === 0) {
            // Chessboard pattern
            let size = radius * 1.5;
            let rotationSpeed = mapValue(bassEnergy, 0, 255, 5, 10);

            // Sub-group that rotates
            let chessGroup = new THREE.Group();
            chessGroup.rotation.z = elapsed * 0.5 * rotationSpeed;
            group.add(chessGroup);

            let cParams = chessParams[i];
            let color1 = mutedPalette[cParams.color1Index];
            let color2 = mutedPalette[cParams.color2Index];

            let w = size * sizeVariation;
            let h = size * sizeVariation;
            let cellW = w / cParams.cols;
            let cellH = h / cParams.rows;

            let startX = -w / 2;
            let startY = -h / 2;

            for (let col = 0; col < cParams.cols; col++) {
              for (let row = 0; row < cParams.rows; row++) {
                let isColor1 = (col + row) % 2 === 0;
                let cellColor = isColor1 ? color1 : color2;

                let geo = new THREE.PlaneGeometry(cellW, cellH);
                let mat = new THREE.MeshBasicMaterial({ color: cellColor });
                let mesh = new THREE.Mesh(geo, mat);
                mesh.position.set(
                  startX + col * cellW + cellW / 2,
                  startY + row * cellH + cellH / 2,
                  0
                );
                chessGroup.add(mesh);
              }
            }

          } else if (i % 2 === 0) {
            // Radial shape (like p5 beginShape/endShape)
            let shapePoints = [];
            for (let angleDeg = 0; angleDeg < 360; angleDeg += angleStep) {
              // approximate noise with random or small range
              let rOffset = randRange(-10, 20);
              let angleRad = (angleDeg * Math.PI) / 180;
              let r = radius + rOffset;
              let x = Math.cos(angleRad) * r;
              let y = Math.sin(angleRad) * r;
              shapePoints.push(new THREE.Vector3(x, y, 0));
            }
            shapePoints.push(shapePoints[0].clone()); // close shape

            let geo = new THREE.BufferGeometry().setFromPoints(shapePoints);
            let col = mutedPalette[i % mutedPalette.length];
            let mat = new THREE.LineBasicMaterial({ color: col });
            let line = new THREE.LineLoop(geo, mat);
            group.add(line);

          } else {
            // Rotating squares
            let squareSize = radius * 1.2;
            for (let j = 0; j < 4; j++) {
              let offset = randRange(-10, 10);
              let geo = new THREE.PlaneGeometry(squareSize + offset, squareSize + offset);
              let col = mutedPalette[i % mutedPalette.length];
              let mat = new THREE.MeshBasicMaterial({
                color: col,
                wireframe: true,
              });
              let mesh = new THREE.Mesh(geo, mat);

              // rotate each one a bit differently
              mesh.rotation.z = (50 * Math.PI) / 180 * j; 
              group.add(mesh);
            }
          }
        });

        renderer.render(scene, camera);
      }

      /***************************************************************
       * Utility Functions
       ***************************************************************/

      // Simple random
      function randRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      // p5-like map
      function mapValue(value, inMin, inMax, outMin, outMax) {
        return ((value - inMin) * (outMax - outMin)) / (inMax - inMin) + outMin;
      }

      // Get average magnitude in a frequency range
      function getFrequencyRangeAverage(analyser, startFreq, endFreq) {
        const data = analyser.getFrequencyData();
        // approximate sample rate or adapt if needed
        const sampleRate = 44100;
        const fftSize = analyser.analyser.fftSize; 
        const freqStep = sampleRate / fftSize;

        let startIndex = Math.floor(startFreq / freqStep);
        let endIndex = Math.floor(endFreq / freqStep);
        startIndex = Math.max(0, startIndex);
        endIndex = Math.min(data.length - 1, endIndex);

        let sum = 0;
        let count = 0;
        for (let i = startIndex; i <= endIndex; i++) {
          sum += data[i];
          count++;
        }
        return count > 0 ? sum / count : 0;
      }

      /***************************************************************
       * Start Audio on pointerdown (optional)
       ***************************************************************/
      window.addEventListener("pointerdown", () => {
        if (sound && !sound.isPlaying) {
          sound.play();
        }
      });
    </script>
  </body>
</html>
