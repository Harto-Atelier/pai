<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Three.js XR - Soft Colors & Slower Movement</title>
  </head>
  <body style="margin:0; padding:0; overflow:hidden;">
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js';
      import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/webxr/VRButton.js';
      // If you want AR:
      // import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/webxr/ARButton.js';

      /****************************************************
       * Configuration
       ****************************************************/
      const numLayers = 16;      // fewer layers => better performance
      const numPoints = 24;      // radial shape resolution
      const angleStep = 360 / numPoints;

      // Soft color palette
      const softPalette = [
        "#b2dfdb", // teal
        "#ffe0b2", // peach
        "#c5cae9", // lavender
        "#ffccbc", // coral
        "#e1bee7"  // pink
      ];

      // We'll alternate shape types: radial or squares
      // We'll store data in an array so we can update each layer in the loop
      let layersData = [];

      // Audio-related
      let analyser, sound;

      // Three.js core
      let scene, camera, renderer;
      let clock;

      init();

      function init() {
        /****************************************************
         * Scene and Camera
         ****************************************************/
        scene = new THREE.Scene();
        // Black background
        scene.background = new THREE.Color(0x000000);

        // For VR, the headset pose will override any manual position
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
        camera.position.set(0, 1.6, 3); // only relevant if VR is not active yet
        scene.add(camera);

        /****************************************************
         * Renderer
         ****************************************************/
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        // Black clear color
        renderer.setClearColor(0x000000, 1);
        document.body.appendChild(renderer.domElement);

        // VR Button (for Quest). If AR, use ARButton instead.
        document.body.appendChild(VRButton.createButton(renderer));
        // document.body.appendChild(ARButton.createButton(renderer));

        clock = new THREE.Clock();

        /****************************************************
         * Audio
         ****************************************************/
        const listener = new THREE.AudioListener();
        camera.add(listener);

        sound = new THREE.Audio(listener);
        const audioLoader = new THREE.AudioLoader();
        audioLoader.load("StanfordOutpatient3piano.mp3", (buffer) => {
          sound.setBuffer(buffer);
          sound.setLoop(true);
          // Must be triggered by user gesture or after session starts
        });

        // Fewer FFT bins => lighter processing
        analyser = new THREE.AudioAnalyser(sound, 512);

        /****************************************************
         * Build Layers (Retained Mode)
         ****************************************************/
        for (let i = 0; i < numLayers; i++) {
          const group = new THREE.Group();
          scene.add(group);

          const rotationOffset = (Math.random() - 0.5) * 0.005; // small => slow rotation
          const waveOffsetX = (Math.random() - 0.5) * 0.5;      // slight random offset
          const waveOffsetZ = -2 - i * 0.4;                     // push each layer further back

          // We'll store geometry references so we can update them in the render loop
          let shapeType = (i % 2 === 0) ? "radial" : "squares";
          let geometry, positions, positionAttr = null;
          let squares = [];

          if (shapeType === "radial") {
            // Create one radial line geometry
            const vertexCount = numPoints + 1; // close shape
            positions = new Float32Array(vertexCount * 3);
            geometry = new THREE.BufferGeometry();
            positionAttr = new THREE.BufferAttribute(positions, 3);
            geometry.setAttribute("position", positionAttr);

            const col = new THREE.Color(softPalette[i % softPalette.length]);
            const mat = new THREE.LineBasicMaterial({ color: col });

            const line = new THREE.LineLoop(geometry, mat);
            group.add(line);

          } else {
            // "squares"
            // We'll create a small set of squares, not re-building them each frame
            // For example, create 4 squares
            for (let s = 0; s < 4; s++) {
              let size = 0.5;
              let geo = new THREE.PlaneGeometry(size, size);
              let col = new THREE.Color(softPalette[i % softPalette.length]);
              let mat = new THREE.MeshBasicMaterial({ color: col, wireframe: true });
              let mesh = new THREE.Mesh(geo, mat);
              mesh.position.set(0, 0, 0);
              mesh.rotation.z = s * 0.5; // small incremental rotation
              group.add(mesh);
              squares.push(mesh);
            }
          }

          layersData.push({
            group,
            shapeType,
            rotationOffset,
            waveOffsetX,
            waveOffsetZ,
            geometry,
            positions,
            positionAttr,
            squares
          });
        }

        /****************************************************
         * Events
         ****************************************************/
        window.addEventListener("resize", onWindowResize, false);

        // Start XR loop
        renderer.setAnimationLoop(render);
      }

      function render() {
        const elapsed = clock.getElapsedTime();

        // Low-impact frequency analysis
        if (analyser) {
          const bass = getFreqRange(analyser, 20, 140);
          const mid = getFreqRange(analyser, 140, 1000);
          const treble = getFreqRange(analyser, 1000, 20000);

          // Subtle amplitude & size Variation
          const amplitude = mid;
          const intensity = THREE.MathUtils.mapLinear(amplitude, 0, 255, 0.01, 0.08);
          const sizeVar = THREE.MathUtils.mapLinear(treble, 0, 255, 0.5, 2.0);

          // update each layer
          layersData.forEach((data, i) => {
            const { group, shapeType, rotationOffset, waveOffsetX, waveOffsetZ,
                    geometry, positions, positionAttr, squares } = data;

            // slow rotation
            group.rotation.z = elapsed * rotationOffset * 2; // small multiplier if needed

            // small wave motion
            group.position.x = waveOffsetX + Math.sin(elapsed * 0.2 + i) * 0.1;
            group.position.y = 0; // floor level
            group.position.z = waveOffsetZ;

            // pick freq val for this layer
            const freqData = analyser.getFrequencyData();
            let freqIndex = Math.floor(THREE.MathUtils.mapLinear(i, 0, numLayers, 0, freqData.length - 1));
            let spectrumVal = freqData[freqIndex];
            let baseRadius = THREE.MathUtils.mapLinear(spectrumVal, 0, 255, 10, 50);
            let radius = baseRadius * intensity;

            if (shapeType === "radial" && positionAttr) {
              // Update radial line geometry
              let idx = 0;
              for (let angleDeg = 0; angleDeg < 360; angleDeg += angleStep) {
                let angleRad = THREE.MathUtils.degToRad(angleDeg);
                // smaller random offset => smoother shape
                let rOffset = (Math.random() - 0.5) * 2;
                let finalR = radius + rOffset;
                positions[idx++] = Math.cos(angleRad) * finalR * sizeVar;
                positions[idx++] = Math.sin(angleRad) * finalR * sizeVar;
                positions[idx++] = 0;
              }
              // close shape
              positions[idx++] = positions[0];
              positions[idx++] = positions[1];
              positions[idx++] = positions[2];

              positionAttr.needsUpdate = true;

            } else if (shapeType === "squares") {
              // rotate squares gently
              squares.forEach((sq, sIndex) => {
                sq.rotation.z += 0.0005; // very slow spin
                // scale based on radius
                let s = (radius * 0.01 + 0.5) * sizeVar;
                sq.scale.set(s, s, 1);
              });
            }
          });
        }

        // Render
        renderer.render(scene, camera);
      }

      /****************************************************
       * Utility Functions
       ****************************************************/
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Get average freq in [startFreq, endFreq]
      function getFreqRange(analyser, minF, maxF) {
        const data = analyser.getFrequencyData();
        const sampleRate = 44100; // approximate
        const fftSize = analyser.analyser.fftSize;
        const freqStep = sampleRate / fftSize;

        let startIndex = Math.floor(minF / freqStep);
        let endIndex = Math.floor(maxF / freqStep);
        startIndex = Math.max(0, startIndex);
        endIndex = Math.min(data.length - 1, endIndex);

        let sum = 0, count = 0;
        for (let i = startIndex; i <= endIndex; i++) {
          sum += data[i];
          count++;
        }
        return count > 0 ? sum / count : 0;
      }

      // Optional: Play audio on pointerdown
      window.addEventListener("pointerdown", () => {
        if (sound && !sound.isPlaying) {
          sound.play();
        }
      });
    </script>
  </body>
</html>
