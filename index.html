<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8"/>
    <title>Three.js VR - Complex, Slow, Pastel Audio Reactive</title>
  </head>
  <body style="margin:0; padding:0; overflow:hidden;">
    <!-- 
      This example:
        - Creates a "wavy" plane reacting to bass.
        - Creates an InstancedMesh of spheres reacting to mid/treble.
        - Uses pastel color palette, slow movement, black background.
        - Retains geometry for performance (no re-creation each frame).
    -->
    <script type="module">
      /******************************************************
       * Imports
       ******************************************************/
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js';
      import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/webxr/VRButton.js';
      // If you want AR, use ARButton instead:
      // import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/webxr/ARButton.js';

      // Noise library for smooth wave displacement
      import SimplexNoise from 'https://cdn.jsdelivr.net/npm/simplex-noise@3.0.1/dist/esm/simplex-noise.js';

      /******************************************************
       * Configuration
       ******************************************************/
      // Plane geometry resolution
      const planeSize = 80;          // overall width/height in scene units
      const planeSegments = 100;     // higher => smoother wave but more vertices (~10k)
      // Instanced spheres
      const instanceCount = 50;      // number of floating spheres
      // Pastel palette
      const pastelPalette = [
        "#b2dfdb", // teal
        "#ffe0b2", // peach
        "#c5cae9", // lavender
        "#ffccbc", // coral
        "#e1bee7"  // pink
      ];

      // We’ll have separate reactivity for bass, mid, treble
      // to show more complexity.
      let scene, camera, renderer;
      let clock;
      let analyser, sound;

      // For the wavy plane
      let waveMesh, wavePositions, waveAttr;
      let noiseGenerator;

      // For the floating spheres (InstancedMesh)
      let sphereMesh;
      let sphereInfos = []; // store random offsets, speeds

      init();

      function init() {
        /******************************************************
         * Basic Scene Setup
         ******************************************************/
        scene = new THREE.Scene();
        // Black background
        scene.background = new THREE.Color(0x000000);

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        // In VR, device pose overrides this, but we set a default
        camera.position.set(0, 1.6, 4);
        scene.add(camera);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        // Make sure background is not transparent
        renderer.setClearColor(0x000000, 1);
        document.body.appendChild(renderer.domElement);

        // VR Button (Quest, etc.). If AR is desired, switch to ARButton.
        document.body.appendChild(VRButton.createButton(renderer));

        clock = new THREE.Clock();

        /******************************************************
         * Audio Setup
         ******************************************************/
        const listener = new THREE.AudioListener();
        camera.add(listener);

        sound = new THREE.Audio(listener);
        const audioLoader = new THREE.AudioLoader();
        // Load your audio file. Adjust path if needed.
        audioLoader.load('StanfordOutpatient3 piano.mp3', buffer => {
          sound.setBuffer(buffer);
          sound.setLoop(true);
          // Must be triggered by user gesture or after XR session start
        });
        // Fewer bins => lighter on performance
        analyser = new THREE.AudioAnalyser(sound, 512);

        // A single instance of Simplex noise
        noiseGenerator = new SimplexNoise();

        /******************************************************
         * 1) Create a Wavy Plane
         ******************************************************/
        // This plane is centered around (0,0). We'll rotate it so we can see it from the front
        const planeGeo = new THREE.PlaneGeometry(
          planeSize,
          planeSize,
          planeSegments,
          planeSegments
        );
        // We'll store a reference to its position buffer
        wavePositions = planeGeo.attributes.position.array;
        waveAttr = planeGeo.attributes.position;
        // Rotate plane so +Y is up, using typical "floor" approach:
        planeGeo.rotateX(-Math.PI / 2);

        // Use a soft color material. We'll pick from the pastel palette randomly.
        let waveColor = new THREE.Color(pastelPalette[Math.floor(Math.random() * pastelPalette.length)]);
        const planeMat = new THREE.MeshLambertMaterial({
          color: waveColor,
          side: THREE.DoubleSide
        });
        waveMesh = new THREE.Mesh(planeGeo, planeMat);
        waveMesh.position.y = 0;  // at "ground" level
        scene.add(waveMesh);

        /******************************************************
         * 2) Lighting
         ******************************************************/
        // For Lambert materials, we need some lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(0, 10, 10);
        scene.add(dirLight);

        /******************************************************
         * 3) Floating Spheres with InstancedMesh
         ******************************************************/
        // We'll create a single sphere geometry & a pastel material
        // Then instance it multiple times
        const sphereGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const sphereMat = new THREE.MeshLambertMaterial({
          color: new THREE.Color(pastelPalette[0])
        });
        sphereMesh = new THREE.InstancedMesh(sphereGeo, sphereMat, instanceCount);
        scene.add(sphereMesh);

        // Each instance gets a transform & random data
        for (let i = 0; i < instanceCount; i++) {
          const matrix = new THREE.Matrix4();

          // Random position near the plane
          let x = (Math.random() - 0.5) * planeSize * 0.6;
          let y = 0.5 + Math.random() * 2.0; // from 0.5 to 2.5
          let z = (Math.random() - 0.5) * planeSize * 0.6;

          // We store each sphere's velocity or offset
          const data = {
            offsetX: Math.random() * 100,
            offsetZ: Math.random() * 100,
            speed: 0.2 + Math.random() * 0.5
          };
          sphereInfos.push(data);

          matrix.makeTranslation(x, y, z);
          sphereMesh.setMatrixAt(i, matrix);
        }
        // We'll update their transforms each frame
        sphereMesh.instanceMatrix.needsUpdate = true;

        /******************************************************
         * Events & Start Animation
         ******************************************************/
        window.addEventListener('resize', onWindowResize, false);
        renderer.setAnimationLoop(render);

        // Optional: Start audio on pointerdown
        window.addEventListener("pointerdown", () => {
          if (sound && !sound.isPlaying) {
            sound.play();
          }
        });
      }

      function render() {
        const elapsed = clock.getElapsedTime();

        // 1) Analyze audio
        const bass = getFreqRange(analyser, 20, 140);
        const mid = getFreqRange(analyser, 140, 1000);
        const treble = getFreqRange(analyser, 1000, 20000);

        // We’ll use:
        // - Bass => wave displacement
        // - Mid => sphere floating speeds
        // - Treble => sphere scale variation

        // 2) Update the wavy plane
        updateWavyPlane(elapsed, bass);

        // 3) Update the floating spheres
        updateFloatingSpheres(elapsed, mid, treble);

        // Render
        renderer.render(scene, camera);
      }

      /******************************************************
       * Wavy Plane Update
       ******************************************************/
      function updateWavyPlane(time, bassVal) {
        // The plane geometry has (planeSegments+1)*(planeSegments+1) vertices
        // wavePositions is a Float32Array: [x0,y0,z0, x1,y1,z1, ...]
        // We'll modify the Y of each vertex based on noise + bass amplitude

        // map bassVal from [0..255] to a smaller range
        let displacementAmp = THREE.MathUtils.mapLinear(bassVal, 0, 255, 0.2, 2.5);

        // We'll iterate each vertex
        const vertexCount = (planeSegments + 1) * (planeSegments + 1);
        let idx = 0;
        for (let i = 0; i < vertexCount; i++) {
          // wavePositions[idx] = x
          // wavePositions[idx+1] = y
          // wavePositions[idx+2] = z
          const xPos = wavePositions[idx];
          const zPos = wavePositions[idx + 2];

          // Use noise with time + xPos/zPos
          // scale coordinates so we get slower waves
          let noiseVal = noiseGenerator.noise2D(xPos * 0.05 + time * 0.1, zPos * 0.05 + time * 0.1);

          // y is a combination of noise and displacementAmp
          wavePositions[idx + 1] = noiseVal * displacementAmp;

          idx += 3;
        }
        // Mark it for update
        waveAttr.needsUpdate = true;
      }

      /******************************************************
       * Floating Spheres Update
       ******************************************************/
      function updateFloatingSpheres(time, midVal, trebleVal) {
        // Map midVal => vertical speed factor
        let speedFactor = THREE.MathUtils.mapLinear(midVal, 0, 255, 0.1, 2.0);
        // Map trebleVal => scale range
        let scaleFactor = THREE.MathUtils.mapLinear(trebleVal, 0, 255, 0.5, 2.0);

        const dummyMatrix = new THREE.Matrix4();
        const dummyPos = new THREE.Vector3();
        const dummyScale = new THREE.Vector3();
        const dummyQuat = new THREE.Quaternion();

        for (let i = 0; i < instanceCount; i++) {
          let info = sphereInfos[i];

          // We'll do a simple up/down bounce with noise
          let xNoise = noiseGenerator.noise2D(info.offsetX, time * info.speed);
          let zNoise = noiseGenerator.noise2D(info.offsetZ, time * info.speed);

          // Original position was around:
          //   x ~ ±(planeSize * 0.6)/2
          //   y ~ [0.5..2.5]
          //   z ~ ±(planeSize * 0.6)/2
          // We'll shift them a bit with the noise
          let baseX = (i * 2.123) % planeSize - planeSize * 0.4; // just some pseudo-random
          let baseZ = (i * 3.451) % planeSize - planeSize * 0.4;
          let baseY = 1.0 + (i % 5);

          // Now add some wave
          dummyPos.set(
            baseX + xNoise * 2.0,        // small horizontal sway
            baseY + Math.sin(time + i) * 0.5, // slow vertical bounce
            baseZ + zNoise * 2.0
          );

          // slow upward movement influenced by midVal
          dummyPos.y += time * 0.05 * speedFactor;

          // if it goes too high, wrap it
          if (dummyPos.y > 8) {
            dummyPos.y = 0.5;
          }

          // scale the sphere by treble-based factor
          let s = 0.3 * scaleFactor;
          dummyScale.set(s, s, s);

          dummyQuat.set(0, 0, 0, 1); // no rotation here, or you can add a spin

          dummyMatrix.compose(dummyPos, dummyQuat, dummyScale);
          sphereMesh.setMatrixAt(i, dummyMatrix);
        }
        sphereMesh.instanceMatrix.needsUpdate = true;
      }

      /******************************************************
       * Helpers
       ******************************************************/
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // Get average magnitude in [startFreq, endFreq]
      function getFreqRange(analyser, startFreq, endFreq) {
        const data = analyser.getFrequencyData();
        const sampleRate = 44100; // approximate
        const fftSize = analyser.analyser.fftSize;
        const freqStep = sampleRate / fftSize;

        let startIndex = Math.floor(startFreq / freqStep);
        let endIndex = Math.floor(endFreq / freqStep);
        startIndex = Math.max(0, startIndex);
        endIndex = Math.min(data.length - 1, endIndex);

        let sum = 0;
        let count = 0;
        for (let i = startIndex; i <= endIndex; i++) {
          sum += data[i];
          count++;
        }
        return count > 0 ? sum / count : 0;
      }
    </script>
  </body>
</html>
