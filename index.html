<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audio Reactive Shader in Three.js</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>
<script>
    let scene, camera, renderer, clock, mesh;
    let listener, sound, audioLoader, analyser;

    function init() {
        // Scene setup
        scene = new THREE.Scene();

        // Camera setup
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 2;

        // Renderer setup
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Audio setup
        listener = new THREE.AudioListener();
        camera.add(listener);
        sound = new THREE.Audio(listener);
        audioLoader = new THREE.AudioLoader();
        analyser = new THREE.AudioAnalyser(sound, 32);

        audioLoader.load('StanfordOutpatient3_piano.mp3', function(buffer) {
            sound.setBuffer(buffer);
            sound.setLoop(true);
            sound.play();
        });

        // Geometry and material using shaders
        const geometry = new THREE.PlaneGeometry(2, 2, 32, 32);
        const material = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                spectrum: { value: new Float32Array(32) }
            },
            vertexShader: `
                uniform float time;
                uniform float spectrum[32];
                varying vec2 vUv;

                void main() {
                    vUv = uv;
                    float freq = spectrum[int(uv.x * 31.0)];
                    vec3 pos = position;
                    pos.z += sin(pos.x * 2.0 + time * 6.28318530718) * cos(pos.y * 2.0 + time * 6.28318530718) * freq * 0.2;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `,
            fragmentShader: `
                varying vec2 vUv;
                void main() {
                    vec3 color = vec3(0.5 + 0.5 * sin(vUv.x + vUv.y), 0.5 + 0.5 * cos(vUv.x + vUv.y), sin(vUv.x + vUv.y));
                    gl_FragColor = vec4(color, 1.0);
                }
            `,
            wireframe: true
        });

        // Mesh creation
        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Handle window resizing
        window.addEventListener('resize', onWindowResize, false);

        // Start animation
        animate();
    }

    function animate() {
        requestAnimationFrame(animate);

        // Update audio data
        if (sound.isPlaying) {
            analyser.getFrequencyData();
            mesh.material.uniforms.spectrum.value = analyser.data;
        }

        // Update time uniform in shader
        mesh.material.uniforms.time.value = clock.getElapsedTime();

        // Render the scene
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Initialize the scene
    clock = new THREE.Clock(true);
    init();
</script>
</body>
</html>
