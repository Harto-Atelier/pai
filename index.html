<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Three.js XR Optimized Example</title>
</head>
<body style="margin:0; overflow:hidden;">
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@latest/build/three.module.js';
import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@latest/examples/jsm/webxr/VRButton.js';
// (You could do ARButton for AR, but let's assume Quest VR usage.)

let scene, camera, renderer;
let clock;
let analyser, sound;

const numLayers = 20;          // fewer for performance
const numPoints = 12;          // fewer points for radial
const angleStep = 360 / numPoints;

// Store data about each layerâ€™s geometry
let layerInfos = [];

init();
function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  camera = new THREE.PerspectiveCamera(
    70,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  // In VR, the headset will override this, but let's set a default
  camera.position.set(0, 1.6, 3);
  scene.add(camera);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  // VR Button
  document.body.appendChild(VRButton.createButton(renderer));

  clock = new THREE.Clock();

  // Audio Setup (optional if you have an audio file)
  const listener = new THREE.AudioListener();
  camera.add(listener);
  sound = new THREE.Audio(listener);
  const audioLoader = new THREE.AudioLoader();
  audioLoader.load('StanfordOutpatient3piano.mp3', (buffer) => {
    sound.setBuffer(buffer);
    sound.setLoop(true);
  });
  analyser = new THREE.AudioAnalyser(sound, 512);

  // Create layers ONCE
  for (let i = 0; i < numLayers; i++) {
    const group = new THREE.Group();
    scene.add(group);

    // Build a radial line geometry
    // We have numPoints + 1 (closing the shape)
    const vertexCount = numPoints + 1;
    const positions = new Float32Array(vertexCount * 3);
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const material = new THREE.LineBasicMaterial({
      color: new THREE.Color(`hsl(${(i * 30) % 360}, 80%, 50%)`),
    });
    const line = new THREE.LineLoop(geometry, material);
    group.add(line);

    // Store references for updating
    layerInfos.push({
      group,
      geometry,
      positions,
      positionAttr: geometry.getAttribute('position'),
      rotationOffset: (Math.random() - 0.5) * 0.5,
    });
  }

  window.addEventListener('resize', onWindowResize);
  renderer.setAnimationLoop(render);
}

// Helper to get frequency range average
function getFreqRange(analyser, minF, maxF) {
  const data = analyser.getFrequencyData();
  const sampleRate = 44100;
  const binCount = analyser.analyser.fftSize;
  const freqStep = sampleRate / binCount;
  let startIndex = Math.floor(minF / freqStep);
  let endIndex = Math.floor(maxF / freqStep);
  startIndex = Math.max(startIndex, 0);
  endIndex = Math.min(endIndex, data.length - 1);
  let sum = 0, count = 0;
  for (let i = startIndex; i <= endIndex; i++) {
    sum += data[i];
    count++;
  }
  return count > 0 ? sum / count : 0;
}

function render() {
  const delta = clock.getDelta();
  const elapsed = clock.getElapsedTime();

  if (analyser) {
    const bass = getFreqRange(analyser, 20, 140);
    const mid = getFreqRange(analyser, 140, 1000);
    const treble = getFreqRange(analyser, 1000, 20000);

    // Example amplitude from mid
    let amplitude = mid;
    let intensity = THREE.MathUtils.mapLinear(amplitude, 0, 255, 0.03, 0.25);
    let sizeVar = THREE.MathUtils.mapLinear(treble, 0, 255, 0.5, 5);

    // Update each layer without removing/adding geometry
    layerInfos.forEach((info, i) => {
      const { group, positions, positionAttr, rotationOffset } = info;

      // Just rotate the group
      group.rotation.z = elapsed * rotationOffset;

      // Slight position wave
      group.position.x = Math.sin(elapsed * 0.01 + i) * 1;
      group.position.z = -2 - i * 0.5;

      // Frequency-based radius
      let freqIndex = Math.floor(THREE.MathUtils.mapLinear(i, 0, numLayers, 0, 511));
      let data = analyser.getFrequencyData();
      let spectrumVal = data[freqIndex];
      let baseRadius = THREE.MathUtils.mapLinear(spectrumVal, 0, 255, 50, 180);
      let radius = baseRadius * intensity;

      // Update radial shape positions
      let idx = 0;
      for (let angle = 0; angle < 360; angle += 360 / numPoints) {
        let angleRad = THREE.MathUtils.degToRad(angle);
        // offset
        let rOffset = (Math.random() - 0.5) * 10; // or some noise
        let finalR = radius + rOffset;
        positions[idx++] = Math.cos(angleRad) * finalR;
        positions[idx++] = Math.sin(angleRad) * finalR;
        positions[idx++] = 0;
      }
      // close shape by repeating first vertex
      positions[idx++] = positions[0];
      positions[idx++] = positions[1];
      positions[idx++] = positions[2];

      // Mark positions as updated
      positionAttr.needsUpdate = true;
    });
  }

  renderer.render(scene, camera);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// Optional user gesture to start audio
window.addEventListener('pointerdown', () => {
  if (sound && !sound.isPlaying) {
    sound.play();
  }
});
</script>
</body>
</html>
